
syntax = "proto3";

package ga4gh_wes_;

// Import HTTP RESTful annotations
import "google/api/annotations.proto";
import "google/protobuf/struct.proto";


// The Workflow Execution Service presents an interoperable layer for executing workflows
// using an HTTP interface. By passing WES messages to a service connected to some execution
// engine one can carry out a computational task.
service WorkflowExecutionService {

  // Get information about Workflow Execution Service.  May include information related (but
  // not limited to) the workflow descriptor formats, versions supported, the WES API versions supported, and information about general the service availability.
  rpc GetServiceInfo(service_info_request) returns (service_info) {
    option (google.api.http) = {
      get: "/ga4gh/wes/v1/service-info"
    };
  }

  // Run a workflow, this endpoint will allow you to create a new workflow request and
  // retrieve its tracking ID to monitor its progress.  An important assumption in this
  // endpoint is that the workflow_params JSON will include parameterizations along with
  // input and output files.  The latter two may be on S3, Google object storage, local filesystems,
  // etc.  This specification makes no distinction.  However, it is assumed that the submitter
  // is using URLs that this system both understands and can access. For Amazon S3, this could
  // be accomplished by given the credentials associated with a WES service access to a
  // particular bucket.  The details are important for a production system and user on-boarding
  // but outside the scope of this spec.
  rpc RunWorkflow(workflow_request) returns (workflow_run_id) {
    option (google.api.http) = {
      post: "/ga4gh/wes/v1/workflows"
      body: "*"
    };
  }

  // Get quick status info about a running workflow.
  rpc GetWorkflowStatus(workflow_run_id) returns (workflow_status) {
      option (google.api.http) = {
        get: "/ga4gh/wes/v1/workflows/{workflow_id}/status"
      };
  }

  // Get detailed info about a running workflow.
  rpc GetWorkflowLog(workflow_run_id) returns (workflow_log) {
      option (google.api.http) = {
        get: "/ga4gh/wes/v1/workflows/{workflow_id}"
      };
  }

  // Cancel a running workflow.
  rpc CancelJob(workflow_run_id) returns (workflow_run_id) {
    option (google.api.http) = {
      delete: "/ga4gh/wes/v1/workflows/{workflow_id}"
    };
  }

  // List the workflows, this endpoint will list the workflows in order of oldest to newest.
  // There is no guarantee of live updates as the user traverses the pages, the behavior should be
  // decided (and documented) by each implementation.
  // To monitor a given execution, use GetWorkflowStatus or GetWorkflowLog.
  rpc ListWorkflows(workflow_list_request) returns (workflow_list_response) {
    option (google.api.http) = {
      get: "/ga4gh/wes/v1/workflows"
    };
  }

}

// To execute a workflow, send a workflow request including all the details needed to begin downloading
// and executing a given workflow.
message workflow_request {
  // OPTIONAL
  // The workflow CWL or WDL document, must provide either this or workflow_url
  string workflow_descriptor = 1;

  // REQUIRED
  // The workflow parameterization document (typically a JSON string), includes all parameterizations for
  // the workflow including input and output file locations
  string workflow_params = 2;

  // REQUIRED
  // The workflow descriptor type, must be "CWL" or "WDL" currently (or another alternative supported by this WES instance)
  string workflow_type = 3;

  // REQUIRED
  // The workflow descriptor type version, must be one supported by this WES instance
  string workflow_type_version = 4;

  // OPTIONAL
  // A key-value map of arbitrary metadata outside the scope of the workflow_params but useful to track with this workflow request
  map<string,string> key_values = 5;

  // OPTIONAL
  // The workflow CWL or WDL document, must provide either this or workflow_descriptor
  string workflow_url = 6;
}

// Request listing of jobs tracked by server
message workflow_list_request {
  // OPTIONAL
  // Number of workflows to return in a page.
  uint32 page_size = 1;

  // OPTIONAL
  // Token to use to indicate where to start getting results. If unspecified, returns the first
  // page of results.
  string page_token = 2;

  // OPTIONAL
  // For each key, if the key's value is empty string then match workflows that are tagged with
  // this key regardless of value
  string key_value_search = 3;
}


// The service will return a workflow_list_response when receiving a successful workflow_list_request.
message workflow_list_response {
  // A list of workflows that the service has executed or is executing.
  repeated workflow_desc workflows = 1;

  // A token, which when provided in a workflow_list_request, allows one to retrieve the next page
  // of results.
  string next_page_token = 2;
}

// The service info request is a simple GET request and doesn't take any parameters.
message service_info_request {}

// A message containing useful information about the running service, including supported versions and
// default settings.
message service_info {
  // A map with keys as the workflow format type name (currently only CWL and WDL are used
  // although a service may support others) and value is a workflow_type_version object which
  // simply contains an array of one or more version strings
  map<string, workflow_type_version> workflow_type_versions = 1;

  // The version(s) of the WES schema supported by this service
  repeated string supported_wes_versions = 2;

  // The filesystem protocols supported by this service, currently these may include common
  // protocols such as 'http', 'https', 'sftp', 's3', 'gs', 'file', 'synapse', or others as
  // supported by this service.
  repeated string supported_filesystem_protocols = 3;

  //The engine(s) used by this WES service, key is engine name e.g. Cromwell and value is version
  map<string,string> engine_versions = 4;

  //The system statistics, key is the statistic, value is the count of workflows in that state.
  // See the State enum for the possible keys.
  map<string,uint32> system_state_counts = 5;

  // A key-value map of arbitrary, extended metadata outside the scope of the above but useful
  // to report back
  map<string,string> key_values = 6;
}

// Small description of workflows, returned by server during listing
message workflow_desc {
  // REQUIRED
  string workflow_id  = 1;

  // REQUIRED
  state state = 2;
}

// Available workflow types supported by a given instance of the service.
message workflow_type_version {
    // an array of one or more version strings
    repeated string workflow_type_version = 1;
}

message workflow_run_id {
  // workflow ID
  string workflow_id = 1;
}

message workflow_status {
  // workflow ID
  string workflow_id = 1;
  // state
  state state = 2;
}

message workflow_log {
  // workflow ID
  string workflow_id = 1;

  // The original request message used to initiate this execution.
  workflow_request request = 2;

  // state
  state state = 3;

  // the logs, and other key info like timing and exit code, for the overall run of this workflow
  log workflow_log = 4;

  // the logs, and other key info like timing and exit code, for each step in the workflow
  repeated log task_logs = 5;

  // the outputs
  google.protobuf.Struct outputs = 6;
}

// Log and other info
message log {
  // The task or workflow name
  string name = 1;
  // The command line that was run
  repeated string cmd = 2;
  // When the command was executed
  string startTime = 3;
  // When the command completed
  string endTime = 4;
  // Sample of stdout (not guaranteed to be entire log)
  string stdout = 5;
  // Sample of stderr (not guaranteed to be entire log)
  string stderr = 6;
  // Exit code of the program
  int32  exitCode = 7;
}

// Enumeration of states for a given workflow request
enum state {
  Unknown = 0;
  Queued = 1;
  Running = 2;
  Paused = 3;
  Complete = 4;
  Error = 5;
  SystemError = 6;
  Canceled = 7;
  Initializing = 8;
}